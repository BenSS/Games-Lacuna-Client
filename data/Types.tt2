###################################################
#
# This is a generated file DO NOT EDIT
# generated by [% generator %] using [% template.name %]
#
###################################################
#
# Any structural changes should be made to [% template_name %]
#
# Any informational changes should be made to one of:
#
[% FOREACH file IN data_files -%]
#     [% file %]
[% END -%]
#
# All changes should be followed by running [% generator %]
#
###################################################
[%
    resource_lists = [];
    FOREACH resource;
        resource_lists.push("${key}_types");
    END;
    tag_functions = ['get_tags','tag_list'];
    meta_functions = [
        'meta_building_list',
        'meta_type',
        'meta_type_list'
    ];
    list_functions = [];
    !list_functions.import(
        resource_lists,
    );
    functions = [];
    # shh!
    !functions.import(
        resource_lists,
        tag_functions,
        meta_functions
    );
%]
package [% package %];

use strict;
use warnings;
use List::MoreUtils qw(any);

require Exporter;

our @ISA = qw(Exporter);
our @EXPORT = qw( [% functions.join(' ') %] );
our %EXPORT_TAGS = (
    list     => [qw( [% list_functions.join(' ') %] )],
    resource => [qw( [% resource_lists.join(' ') %] )],
    tag      => [qw( [%  tag_functions.join(' ') %] )],
    meta     => [qw( [% meta_functions.join(' ') %] )],
    all      => [@EXPORT],
);
[% FOREACH resource %]
{
    my @[% key %] = qw( [% value.join(' ') %] );
    sub [% key %]_types {
        return @[% key %];
    }
}
[% END %]
{
    my %meta_types = (
        [%~ FOREACH building_type IN building_meta.keys.sort %]
        [% building_type %] => [qw(
            [%~ FOREACH building IN building_meta.$building_type.sort %]
            [% building ; END %]
        )],
        [%~ END %]
    );

    sub meta_type {
        my( $building ) = @_;
        return unless $building;
        for my $k ( keys %meta_types ){
            if( any {$_ eq $building} @{$meta_types{$k}} ){
                return $k;
            }
        }
        return;
    }
    sub meta_type_list{
        return keys %meta_types if wantarray;
        return [keys %meta_types];
    }
    sub meta_building_list {
        my( $type ) = @_;
        return unless $type;
        my $buildings = $meta_types{$type};
        return @$buildings if wantarray;
        return [@$buildings];
    }
}
{
    my @tags = qw([% building_data.tag_list.join(' ') %]);
    sub tag_list {
        return @tags;
    }
}
{
    my %tags = (
    [%- FOREACH building_data.tags %]
        [% key %] => [qw([% value.join(' ') %])],
    [%- END %]
    );
    sub get_tags{
        my( $building ) = @_;
        return @{ $tags{$building} };
    }
}
1;

__END__

=head1 NAME

[% package %]

=head1 SYNOPSIS

    use [% package %];

=head1 FUNCTIONS

=over 4
[% FOREACH function IN functions %]
=item [% function %]
[% END %]
=back

=cut
